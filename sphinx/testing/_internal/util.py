"""Private utililty functions for :mod:`sphinx.testing.plugin`.

This module is an implementation detail and any provided function
or class can be altered, removed or moved without prior notice.
"""

from __future__ import annotations

__all__ = ()

import binascii
import json
import os
import pickle
from functools import lru_cache
from typing import TYPE_CHECKING, overload

import pytest

if TYPE_CHECKING:
    from typing import Any, Final

    from _pytest.nodes import Node as PytestNode


UID_BITLEN: int = 32
r"""The bit-length of unique identifiers generated by this module.

Must be a power of two in :math:`[8, 128]`.
"""
UID_BUFLEN: Final[int] = UID_BITLEN // 8
UID_HEXLEN: Final[int] = UID_BITLEN // 4


# fmt: off
@overload
def make_unique_id() -> str: ...  # NoQA: E704
@overload
def make_unique_id(prefix: str | os.PathLike[str]) -> str: ...  # NoQA: E704
# fmt: on
def make_unique_id(prefix: str | os.PathLike[str] | None = None) -> str:  # NoQA: E302
    r"""Generate a random unique identifier prefixed by *prefix*.

    :param prefix: An optional prefix to prepend to the unique identifier.
    :return: A random unique identifier.
    """
    suffix = os.urandom(UID_BUFLEN).hex()
    return '-'.join((os.fsdecode(prefix), suffix)) if prefix else suffix


def get_objects_checksum(*args: Any, **kwargs: Any) -> int:
    """Compute a CRC-32 checksum of arbitrary objects.

    The order of the positional arguments and keyword arguments matters
    when computing the checksum, hence it is recommended to only use
    keyword arguments whenever possible.

    If an object cannot be pickled, its representation is based on the value
    of its :func:`id`, possibly making the checksum distinct for equivalent
    but non-pickable objects.
    """

    def default_encoder(x: object) -> str:
        try:
            return pickle.dumps(x, protocol=pickle.HIGHEST_PROTOCOL).hex()
        except (NotImplementedError, TypeError, ValueError):
            return format(id(x), 'x')

    # use the most compact JSON format
    data = [args, kwargs]
    env = json.dumps(data, separators=(',', ':'), default=default_encoder, sort_keys=True)
    # avoid using unique_object_id() since we do not really need SHA-1 entropy
    return binascii.crc32(env.encode('utf-8'))


@lru_cache(maxsize=65536)
def unique_object_id(name: str) -> str:
    """Get a unique hexadecimal identifier for an object name.

    :param name: The name of the object to get a unique ID of.
    :return: A unique hexadecimal identifier for *name*.
    """
    from hashlib import sha1

    # ensure that non UTF-8 characters are supported and handled similarly
    h = sha1(name.encode('utf-8', errors='backslashreplace'))
    byt = int.from_bytes(h.digest()[:UID_BUFLEN], byteorder='little')
    return f'%00{UID_HEXLEN}x' % byt


def get_container_id(node: PytestNode) -> str:
    """Get a unique identifier for the node's container.

    The node's container is defined by all but the last component of the
    node's path (e.g., ``pkg.mod.test_func`` is contained in ``pkg.mod``).
    """

    def get_obj_name(subject: PytestNode) -> str | None:
        if isinstance(subject, pytest.Package):
            return subject.name
        if isinstance(subject, (pytest.Module, pytest.Class)):
            return getattr(subject.obj, '__name__', None)
        return None

    names = map(get_obj_name, node.listchain())
    container = '@'.join(filter(None, names)) or node.nodeid
    return unique_object_id(container)


def get_location_id(location: tuple[str, int]) -> str:
    """Get a unique hexadecimal identifier out of a test location.

    The ID is based on the physical node location (file and line number).
    The line number is a 0-based integer but can be -1 if unknown.
    """
    fspath, lineno = location
    return unique_object_id(f'{fspath}:L{lineno}')
